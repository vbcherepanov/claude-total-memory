# Memory System — Project Configuration

# Replace "my-project" with your actual project name everywhere below.

## AUTO-RECALL: Search Memory Before Every Task

Before starting ANY task, Claude MUST search for relevant past knowledge:

```
memory_recall(query="<description of current task>", project="my-project")
```

This is MANDATORY. Do not skip this step. Past decisions, solutions, and lessons
are only useful if they are found before repeating mistakes.

Examples of good recall queries:
- "docker networking configuration" (before working on Docker)
- "API authentication approach" (before touching auth code)
- "database migration patterns" (before creating migrations)
- "deployment pipeline" (before CI/CD changes)

## AUTO-SAVE: Save Knowledge Automatically

Claude MUST call `memory_save` automatically after significant actions.
Do NOT ask the user "should I save this?" -- just save it.

### When to save (automatic triggers):

| Trigger | type | What to save |
|---------|------|--------------|
| Made an architectural decision | `decision` | The decision + WHY + rejected alternatives |
| Fixed a non-trivial bug | `solution` | Symptom -> root cause -> fix |
| Discovered a gotcha/pitfall | `lesson` | Expected vs actual behavior + takeaway |
| Set up infrastructure/config | `fact` | Configuration details + key parameters |
| Established a project pattern | `convention` | The rule + code example |
| Completed a git commit | `fact` | Commit scope + key changes |
| Ending a session | `fact` | Summary: what was done, what remains |

### When NOT to save (avoid noise):

- Trivial edits (formatting, imports, typo fixes)
- Intermediate steps (running tests, reading files)
- Information obvious from the code itself
- Duplicate of something already saved

### Save format — always include project and tags:

```
memory_save(
    content="Brief, actionable description of the knowledge",
    type="solution",
    project="my-project",
    tags=["relevant", "searchable", "tags"],
    context="Additional context. For decisions: always explain WHY."
)
```

### Quality rules:

1. **One knowledge = one save** (do not mix different topics)
2. **`project` is required** (enables filtered recall)
3. **`tags` are required** (enables tag-based browsing)
4. **`context` for decisions** — always include WHY and rejected alternatives
5. **Be concise** — future recall should be fast to scan
6. **Duplicates are OK** — the server auto-deduplicates (Jaccard + fuzzy)

## Knowledge Types

| Type | When | Example |
|------|------|---------|
| `decision` | Architectural choice (**must include WHY**) | "Chose PostgreSQL over MySQL because of JSONB support and temporal queries" |
| `solution` | Bug fix or workaround | "Fixed timeout by chunking batch requests to 50 items with 200ms delay" |
| `lesson` | Gotcha or pitfall discovered | "Docker Compose v2 requires depends_on.condition: service_healthy -- silent failure without it" |
| `fact` | Config, version, endpoint | "Production DB: PostgreSQL 18 on port 5433, max_connections=200" |
| `convention` | Project pattern or rule | "All DTOs must be final readonly classes with constructor promotion" |

## Browse and Maintain

```
memory_timeline(sessions_ago=1)                     # What happened last session
memory_timeline(query="docker")                     # Find sessions about docker
memory_stats()                                      # Health metrics and storage
memory_search_by_tag(tag="api", project="my-project") # Browse by tag
memory_consolidate(dry_run=true)                    # Preview duplicate merges
memory_forget(dry_run=true)                         # Preview retention cleanup
memory_update(find="old fact", new_content="new")   # Update existing knowledge
```

## Advanced

```
memory_recall(query="topic", detail="summary")           # Token-saving mode (150 chars)
memory_history(id=42)                                    # Version chain for a record
memory_delete(id=42)                                     # Soft-delete a record
memory_relate(from_id=1, to_id=2, type="solution")      # Link related records
memory_extract_session(action="list")                    # Pending transcript extractions
```

## Self-Improvement (Automatic Error Learning)

Claude learns from mistakes across sessions via a 3-level pipeline.

### At session start — load behavioral rules:
```
self_rules_context(project="my-project")
```

### On any error (bash failure, wrong assumption, API error) — log it automatically:
```
self_error_log(
    description="What went wrong",
    category="code_error",
    fix="How it was fixed",
    project="my-project"
)
```

Categories: `code_error`, `logic_error`, `config_error`, `api_error`, `timeout`, `loop_detected`, `wrong_assumption`, `missing_context`

### When patterns emerge (3+ similar errors) — extract insight:
```
self_insight(action="add", content="Lesson learned", category="code_error")
```

### At session end — reflect:
```
self_reflect(reflection="What went well, what to improve", task_summary="What was done")
```

### Analyze improvement:
```
self_patterns(view="full_report", project="my-project")
```

## Web Dashboard

Open http://localhost:37737 to browse knowledge, sessions, and the knowledge graph.
